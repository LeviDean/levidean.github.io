[{"categories":["Blockchain"],"contents":"GitHub: PoE Pallet\nQ1. #![cfg_attr(not(feature = \u0026ldquo;std\u0026rdquo;), no_std)] 是什么意思 cfg_attr(ConfigurationPredicate, CfgAttrs?)，当 ConfigurationPredicate 成立时，会对后面的 CfgAttrs 展开。由于我们在 Cargo.toml 的 features 中引入了 std，因此 not(feature = \u0026quot;std\u0026quot;) 的值为 False，不会对 no_std 进行展开。如果前面值为 True，则会展开为 ![no_std]，引入 Rust 核心库而非标准库。\nhttps://rustwiki.org/en/reference/conditional-compilation.html#the-cfg_attr-attribute\nQ2. Get\u0026lt;u32\u0026gt; 是什么 Get\u0026lt;T\u0026gt; 是一个预定义的trait frame_support::pallet_prelude::Get\npub trait Get\u0026lt;T\u0026gt; {  fn get() -\u0026gt; T; } 在 runtime 中，我们引入 poe 时：\nimpl pallet_poe::Config for Runtime { \ttype MaxClaimLength = ConstU32\u0026lt;512\u0026gt;; \ttype Event = Event; } 而 ConstU32 的定义来源于：\nmacro_rules! impl_const_get { \t($name:ident, $t:ty) =\u0026gt; { \t#[doc = \u0026#34;Const getter for a basic type.\u0026#34;] \t#[derive($crate::RuntimeDebug)] \tpub struct $name\u0026lt;const T: $t\u0026gt;; \timpl\u0026lt;const T: $t\u0026gt; Get\u0026lt;$t\u0026gt; for $name\u0026lt;T\u0026gt; { \tfn get() -\u0026gt; $t { \tT \t} \t} \timpl\u0026lt;const T: $t\u0026gt; Get\u0026lt;Option\u0026lt;$t\u0026gt;\u0026gt; for $name\u0026lt;T\u0026gt; { \tfn get() -\u0026gt; Option\u0026lt;$t\u0026gt; { \tSome(T) \t} \t} \timpl\u0026lt;const T: $t\u0026gt; TypedGet for $name\u0026lt;T\u0026gt; { \ttype Type = $t; \tfn get() -\u0026gt; $t { \tT \t} \t} \t}; }  impl_const_get!(ConstU32, u32); Get\u0026lt;T\u0026gt; 可以通过 get() 得到变量内部的值。\nhttps://paritytech.github.io/substrate/master/frame_support/pallet_prelude/trait.Get.html https://paritytech.github.io/substrate/master/src/sp_runtime/traits.rs.html#322\nQ3. frame_support::BoundedVec pub struct BoundedVec\u0026lt;T, S\u0026gt;( \tpub(super) Vec\u0026lt;T\u0026gt;, \t#[cfg_attr(feature = \u0026#34;std\u0026#34;, serde(skip_serializing))] PhantomData\u0026lt;S\u0026gt;, );  impl\u0026lt;T, S: Get\u0026lt;u32\u0026gt;\u0026gt; BoundedVec\u0026lt;T, S\u0026gt; { \t... \t/// Get the bound of the type in `usize`. \tpub fn bound() -\u0026gt; usize { \tS::get() as usize \t}  ... }  impl\u0026lt;T, S: Get\u0026lt;u32\u0026gt;\u0026gt; TryFrom\u0026lt;Vec\u0026lt;T\u0026gt;\u0026gt; for BoundedVec\u0026lt;T, S\u0026gt; { \ttype Error = (); \tfn try_from(t: Vec\u0026lt;T\u0026gt;) -\u0026gt; Result\u0026lt;Self, Self::Error\u0026gt; { \tif t.len() \u0026lt;= Self::bound() { \t// explicit check just above \tOk(Self::unchecked_from(t)) \t} else { \tErr(()) \t} \t} } BoundedVec 可以看作是一个长度受限的 Vec。\nhttps://paritytech.github.io/substrate/master/src/sp_runtime/bounded/bounded_vec.rs.html#45\nQ4. 为什么要在 BoundedVec::try_from 后加 map_err 从Q3可以看出，当 try_from 的长度超出限制时，返回的是 Err(())，通过 map_err 转换成我们自定义的错误并返回。\nQ5. assert_noop! 宏 #[macro_export] #[cfg(feature = \u0026#34;std\u0026#34;)] macro_rules! assert_noop { \t( \t$x:expr, \t$y:expr $(,)? \t) =\u0026gt; { \tlet h = $crate::storage_root(); \t$crate::assert_err!($x, $y); \tassert_eq!(h, $crate::storage_root()); \t} } 判断表达式是否返回期待的错误，并且表达式本身并没有改变runtime的storage\nhttps://docs.rs/frame-support/2.0.0-rc4/src/frame_support/lib.rs.html#300-309\nQ6. new_test_ext().execute_with 在 mock.rs 中 new_test_ext 会返回 TestExternalities:\nimpl\u0026lt;H\u0026gt; TestExternalities\u0026lt;H\u0026gt; where \tH: Hasher + \u0026#39;static, \tH::Out: Ord + \u0026#39;static + codec::Codec, {  ...  /// Execute the given closure while `self` is set as externalities. \t/// \t/// Returns the result of the given closure. \tpub fn execute_with\u0026lt;R\u0026gt;(\u0026amp;mut self, execute: impl FnOnce() -\u0026gt; R) -\u0026gt; R { \tlet mut ext = self.ext(); \tsp_externalities::set_and_run_with_externalities(\u0026amp;mut ext, execute) \t}  ... } execute_with 可以传入一个闭包来执行，并返回结果。\nhttps://paritytech.github.io/substrate/master/src/sp_state_machine/testing.rs.html#193\n","date":"2022-09-02T19:12:21+08:00","permalink":"https://levidean.github.io/post/20220902substrate-poe-note/","section":"post","tags":["Substrate","Pallet","PoE"],"title":"PoE Pallet 实现笔记"},{"categories":["Rust"],"contents":"PartialEq 我们先定义一个 User struct：\nstruct User {  id: String,  age: u32,  name: String, } 那么当我们想看两个 user 是否是同一个人时：\nlet user_a = User {id: \u0026#34;12345\u0026#34;.to_string(), age: 10, name: \u0026#34;Alice\u0026#34;.to_string()}; let user_b = User {id: \u0026#34;12345\u0026#34;.to_string(), age: 10, name: \u0026#34;Alice\u0026#34;.to_string()}; if user_a == user_b {  println!(\u0026#34;Is the same person.\u0026#34;); } 显而易见，直接用 == 编译器一定会报错。编译器提醒我们 User 缺少 PartialEq\u0026lt;_\u0026gt; 的实现, 可以通过添加派生宏 #[derive(PartialEq)] 来解决这个问题：\n --\u0026gt; src/main.rs:11:15 | 11 | if user_a == user_b { | ------ ^^ ------ User | | | User | note: an implementation of `PartialEq\u0026lt;_\u0026gt;` might be missing for `User` --\u0026gt; src/main.rs:2:1 | 2 | struct User { | ^^^^^^^^^^^ must implement `PartialEq\u0026lt;_\u0026gt;` help: consider annotating `User` with `#[derive(PartialEq)]` | 2 | #[derive(PartialEq)] | 然后通过 cargo expand 可以看到派生宏为 User 实现了两个 trait：\nimpl ::core::marker::StructuralPartialEq for User {} #[automatically_derived] #[allow(unused_qualifications)] impl ::core::cmp::PartialEq for User {  #[inline]  fn eq(\u0026amp;self, other: \u0026amp;User) -\u0026gt; bool {  match *other {  User {  id: ref __self_1_0,  age: ref __self_1_1,  name: ref __self_1_2,  } =\u0026gt; match *self {  User {  id: ref __self_0_0,  age: ref __self_0_1,  name: ref __self_0_2,  } =\u0026gt; {  (*__self_0_0) == (*__self_1_0)  \u0026amp;\u0026amp; (*__self_0_1) == (*__self_1_1)  \u0026amp;\u0026amp; (*__self_0_2) == (*__self_1_2)  }  },  }  }  #[inline]  fn ne(\u0026amp;self, other: \u0026amp;User) -\u0026gt; bool {  match *other {  User {  id: ref __self_1_0,  age: ref __self_1_1,  name: ref __self_1_2,  } =\u0026gt; match *self {  User {  id: ref __self_0_0,  age: ref __self_0_1,  name: ref __self_0_2,  } =\u0026gt; {  (*__self_0_0) != (*__self_1_0)  || (*__self_0_1) != (*__self_1_1)  || (*__self_0_2) != (*__self_1_2)  }  },  }  } } 其中 ::core::marker::StructuralPartialEq 的代码块为空，任何派生 PartialEq 的类型都会自动实现这个 trait。\n另一个就是关键的 PartialEq 了。可以看到主要是实现了 eq(...) 和 ne(...) 两个函数，函数内部执行的是模式匹配，当两者内部的值来返回 true 或者 false，也就是重载了 == 和 !=。\n所以如果 struct 要实现 PartialEq 那么它的成员类型也必须都要实现 PartialEq。\nEq Rust 中还有一个 trait Eq, 也同样可以通过派生宏 #[derive(Eq)] 实现，代码展开后为：\nimpl ::core::marker::StructuralEq for User {} #[automatically_derived] #[allow(unused_qualifications)] impl ::core::cmp::Eq for User {  #[inline]  #[doc(hidden)]  #[no_coverage]  fn assert_receiver_is_total_eq(\u0026amp;self) -\u0026gt; () {  {  let _: ::core::cmp::AssertParamIsEq\u0026lt;String\u0026gt;;  let _: ::core::cmp::AssertParamIsEq\u0026lt;u32\u0026gt;;  let _: ::core::cmp::AssertParamIsEq\u0026lt;String\u0026gt;;  }  } } 上面这段代码似乎没做什么事，其实从名字也可以看出差异 PartialEq 是局部等价，而完全等价需要满足：\n 自反性： x == x 对称性： x == y 意味着 y == x 传递性： x == y, y == z, 意味着 x == z  PartialEq 和 Eq 的区别主要在于类型是否自反性，例如，因为在 Rust 中 NaN != NaN，所以对于浮点类型只实现了 PartialEq。 所以 Eq 的主要作用就是让编译器知道该类型具有自反性。也由此可知，Eq 需要基于 PartialEq实现。\n","date":"2022-07-12T23:12:12+08:00","permalink":"https://levidean.github.io/post/20220712rust-eq-partialeq/","section":"post","tags":["Macro","Eq","PartialEq"],"title":"Rust中的Eq和PartialEq"},{"categories":["Blockchain"],"contents":"运行时定义了哪些事务是有效或者无效的，并确定了链状态是如何响应事务并发生变化的。在 Substrate 中，运行时就是区块链的“状态转移函数”。 Substrate 的开发者主要做的一部分工作就是定义代表区块链状态的存储项和用来改变这些状态的函数。 在 Substrate 中运行时代码会被编译成 Wasm ，也可以编译成本地的 rust 运行时。启动节点时会根据版本信息来选择调用哪个运行时。除了运行时之外的其他代码（客户端）只会编译成本地的 rust 二进制，不会被编译成 Wasm 。 比如 p2p 、 RPC 等。客户端在执行任务时，会通过 API 与运行时进行交互。\n##运行时APIs 在 Substrate 中，可以通过 sp_api crate 让开发者制定运行时API 。但要保证运行时必须实现 Core 运行时 API 和 Metadata 运行时 API 。 基础的 Substrate 节点实现了一些运行时API：\n BlockBuilder: Provides the functionality required for building a block. TaggedTransactionQueue: Handles validating transactions in the transaction queue. OffchainWorkerApi: Handles off-chain capabilities. AuraApi: Handles block authorship with Aura consensus. SessionKeys: Generates and decodes session keys. GrandpaApi: Integrates the GRANDPA finality gadget into the runtime. AccountNonceApi: Handles querying transaction indices. TransactionPaymentApi: Handles querying information about transactions. Benchmark: Provides a way to benchmark a FRAME runtime.  除此之外的一些 API 可以由开发者来声明并实现。 通常在运行时外使用宏 decl_运行时_apis 声明 API ， 然后在运行时里面使用宏 impl_运行时_apis 进行实现。\nCore primitives 为了保证运行时可以与 Substrate 框架中的其他部分一同工作。运行时 必须要实现一些核心原语，有些数据类型必须要被定义并提供一个特定的接口。\n Hash: A type which encodes a cryptographic digest of some data. Typically just a 256-bit quantity. DigestItem: A type which must be able to encode one of a number of \u0026ldquo;hard-wired\u0026rdquo; alternatives relevant to consensus and change-tracking as well as any number of \u0026ldquo;soft-coded\u0026rdquo; variants, relevant to specific modules within the runtime. Digest: A series of DigestItems. This encodes all information that is relevant for a light-client to have on hand within the block. Extrinsic: A type to represent a single piece of data external to the blockchain that is recognized by the blockchain. This typically involves one or more signatures, and some sort of encoded instructions (e.g. for transferring ownership of funds or calling into a smart contract). Header: A type which is representative (cryptographically or otherwise) of all information relevant to a block. It includes the parent hash, the storage root and the extrinsics trie root, the digest and a block number. Block: Essentially just a combination of Header and a series of Extrinsics, together with a specification of the hashing algorithm to be used. BlockNumber: A type which encodes the total number of ancestors any valid block has. Typically a 32-bit quantity.  FRAME primitives Substrate 的代码库中自带 FRAME，一个用于 Substrate运行时开发系统。 FRAME 定义了额外的运行时原语，并提供了一个框架，能够更容易的通过组合模块来构建运行时, 这些模块叫作 Pallets。 每个 pallet 封装了特定领域的逻辑，例如存储项、事件、错误、调用函数。开发者可以创建自己的 pallet 也可以直接使用现成的 pallet， Substrate 提供了50多种不同的 pallets 。 下面这张图示意了 pallet 和运行时的关系。有颜色的 pallets 被用来构建图片下方的运行时。\n对于 Substrate FRAME 构建的运行时还假定了另外一组原语：\n Call: The dispatch type that can be called via an extrinsic. Origin: Represents where a call came from. For example, a signed message (a transaction), an unsigned message (an inherent extrinsic), or a call from the runtime itself (a root call). Index: An account index (aka nonce) type. This stores the number of previous transactions associated with a sender account. Hashing: The hashing algorithm being used in the runtime (e.g. Blake2). AccountId: The type used to identify user accounts in the runtime. Event: The type used for events emitted by the runtime. Version: A type which represents the version of the runtime.  虽然很多运行时开发都可以使用 FRAME 及其相关原语，但 FRAME 并不是开发 Substrate 区块链的唯一途径。\n","date":"2022-06-09T17:58:18+08:00","permalink":"https://levidean.github.io/post/20220609substrate-runtime/","section":"post","tags":["Substrate","Runtime"],"title":"初识Substrate - Runtime"},{"categories":null,"contents":"TBD\n","date":"2022-05-30T12:16:10+08:00","permalink":"https://levidean.github.io/about/","section":"","tags":null,"title":"About"},{"categories":["Notes"],"contents":"觉得有必要搭建一下blog，记录一下自己的一些学习笔记。没有写网页的基础，又觉得租服务器和域名备案太麻烦了，所以选择了高效低成本的方法：github pages + 静态网站 的方式。 然后在Hexo、Jekyll和Hugo中纠结了一番，虽然github pages自带Jekyll，但相比之下，Hugo的社区群体更大，也拥有更多的主题，因此就选择了使用Hugo来搭建。 Hugo是用Golang写的，因此它生成网站的速度也更快一些。\n安装Hugo 这部分可以直接参考Hugo官网的Doc。\n快速搭建 安装完Hugo后，可以通过一下命令快速创建网站项目\nhugo new site my_blog 然后就会在当前路径下生成名为 my_blog/ 的文件夹以及内部基础的文件。接下来就需要为你的网站设置一个主题。\n选择主题 前面说到Hugo的主题很多，都可以在它的官网上找到。 我选的主题是He Yeshuang分享的Tokiwa。 主题的设置也很简单，以Tokwa为例，首先把主题的源码clone到项目根目录下的 theme/ 文件夹中\ncd my_blog git submodule add https://github.com/heyeshuang/hugo-theme-tokiwa.git themes/hugo-theme-tokiwa 然后，修改根目录下的 config.toml 文件，在里面加上一句\ntheme = \u0026#34;hugo-theme-tokiwa\u0026#34; 随后便会找到**theme/**文件夹下同名的主题并应用。\n或者，通常主题源码被clone下来后，会带有配置示例，一般会放在 theme/xxx/exampleSite/ 文件夹下，把里面的文件复制到网站根目录下替换原有文件即可。\n然后我们可以在根目录下执行\nhugo server 然后通过 http://localhost:1313/ ，来查看网站大概长什么样。\n部署到GitHub Pages 首先创建 xxx.github.io 的repo（参考官网）。 随后在 config.toml 文件中添加\nbaseURL = \u0026#34;https://xxxxx.github.io/\u0026#34; 来制定网站域名，执行\nhugo 生成静态网站资源，然根目录下会生成新的文件夹 public/ ，我们将这个文件夹和我们的 pages repo 链接\ncd public git init git add . git commit -m\u0026#34;blog init\u0026#34; git remote add origin https://github.com/xxx/xxx.github.io.git git branch -M main git push origin main Github pages生效需要一些时间，等一会就可以通过 https://xxx.github.io 来访问自己的博客了。\n发布文章 通过以下名来生成新的文件\nhugo new post/20220530BuildBlog.md 并通过修改markdown文件的头部内容来为文章添加tags和分类，以及其他的一些属性\n--- title: \u0026#34;搭建 Hugo + Github Pages 博客\u0026#34; date: 2022-05-30T08:51:20+08:00 draft: true description: \u0026#34;记录一下如何构建Hugo博客\u0026#34; tags: [\u0026#34;Blog\u0026#34;, \u0026#34;Hugo\u0026#34;] categories: [\u0026#34;记录\u0026#34;] toc: true --- 文章完成后就可以通过 hugo 命令来生成网站，再把 public/ 更新到GitHub上。（记得把文章的draft属性设置为false)\n添加评论模块 Tokiwa用的是Hugo内置的Disqus模块，但在国内感觉这个用起来不太方便， 就找了个平替，基于Github issue search API的utterances，可有通过Github账号来进行评论 配置起来也特别方便，安装utterances github app，然后配置可以直接选择我们 xxxx.github.io 的repo， 这样的话之后关于我们文章的评论都会以issue的形式存储在这个仓库中。\n然后就是要把这个模块添加到我们的site中，首先我们要找到我们希望放置评论模块的位置，我们文章的页面是通过模版生成的，所以需要修改统一的模板， 还是以Tokiwa为例，Tokiwa评论的模板位置放在 themes/hugo-theme-tokiwa/layouts/partials/page-footer.html ， 可以看到最下面有\n\u0026lt;div class=\u0026#34;pb-2\u0026#34;\u0026gt;  {{ template \u0026#34;_internal/disqus.html\u0026#34; . }} \u0026lt;/div\u0026gt; 这是使用了Hugo的内置模板，我们需要做的就是替换掉这部分，首先我们创建一个新的文件 themes/hugo-theme-tokiwa/layouts/partials/utterances.html\n\u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34;  repo=\u0026#34;xxx/xxx.github.io\u0026#34;  issue-term=\u0026#34;pathname\u0026#34;  theme=\u0026#34;github-light\u0026#34;  crossorigin=\u0026#34;anonymous\u0026#34;  async\u0026gt; \u0026lt;/script\u0026gt; 这部分代码utterances主页上有根据不同需求生成，记得替换其中的repo即刻，然后我们把刚刚footer中的模板替换掉就可以了。\n\u0026lt;div class=\u0026#34;pb-2\u0026#34;\u0026gt;  {{ partial \u0026#34;utterances.html\u0026#34; . }} \u0026lt;/div\u0026gt; 其他主题也是差不多，效果就像下面一样了。\n","date":"2022-05-30T08:51:20+08:00","permalink":"https://levidean.github.io/post/20220530build-blog/","section":"post","tags":["Blog","Hugo"],"title":"搭建 Hugo + Github Pages 博客"},{"categories":null,"contents":"","date":"2022-05-30T00:00:00Z","permalink":"https://levidean.github.io/archives/","section":"","tags":null,"title":""}]